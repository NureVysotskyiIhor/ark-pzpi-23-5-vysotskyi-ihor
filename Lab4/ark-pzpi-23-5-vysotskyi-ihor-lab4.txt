МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ






Звіт
з лабораторної роботи № 4
з дисципліни
«Аналіз та рефакторинг коду»









Виконав:	Перевірив:
ст. гр. ПЗПІ-23-5	ст. викладач кафедри ПІ
Висоцький І. О.	Сокорчук Ігор Петрович












2025

1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень123.12.20250.1Створено розділ "Опис виконаної роботи"
      



     2 ЗАВДАННЯ
     1. Розробити будову програмного забезпечення IoT клієнта
     2. Створити UML діаграму прецедентів для IoT клієнта
     3. Розробити бізнес логіку IoT клієнта
     4. Створити діаграму діяльності для IoT клієнта
     5. Розробити функції налаштування IoT клієнта
     6. Створити програмну реалізацію бізнес логіки та функцій налаштування
     7. Перевірити роботу IoT клієнта
     8. Завантажити програмний код у GitHub репозиторій
     9. Створити відеозапис демонстрації функціональності
     10. Експортувати звіт у PDF та текстовий файл

     3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Архітектура IoT Клієнта
     IoT клієнт розроблено на базі мікроконтролера ESP32 DevKit V1 для реалізації рейтинг-голосувань в режимі реального часу. Система побудована за принципом модульної архітектури з чітким поділом відповідальності між компонентами.
     Основні компоненти системи:
     1. Система управління конфігурацією (DeviceConfig) — зберігає параметри кіоска: унікальний ідентифікатор пристрою (UUID), інтервали синхронізації та показу опитувань, пороги валідації голосів. Конфіг завантажується з внутрішньої пам'яті EEPROM та може динамічно оновлюватися з сервера без перезавантаження пристрою.
     2. Управління станом опитування (CurrentPoll) — зберігає метаінформацію про поточне активне опитування: ID, назву, питання, максимальну шкалу рейтингу (1-5), статус активності. Оновлюється через REST запити до сервера кожні 30 секунд.
     3. Розрахунок метрик якості голосу (VoteMetrics) — структура яка містить розраховані математичні показники: впевненість користувача (confidence за сигмоїдною функцією часу), аномалія активності (Z-score для виявлення ботів), ентропія Шеннона (невизначеність вибору), статус валідації голосу (APPROVED/SUSPICIOUS/REJECTED).
     4. Взаємодія з сервером — реалізована через REST API з трьома основними endpoint'ами для синхронізації конфігу, запиту опитувань та реєстрації голосів з повною інформацією про якість голосування.
     5. Індикація та логування — система сигналізує результат через LED індикатори (зелена для успіху, червона для помилок) та виводить детальні логи в серійний порт для моніторингу роботи.
     3.2 Бізнес-логіка IoT Клієнта
     3.2.1 Функція calculateConfidence()
     Розраховує впевненість користувача через сигмоїдну функцію на основі часу голосування. Сигмоїдна крива забезпечує гладку трансформацію часу в значення впевненості від 0 до 1:
     Формула: confidence = 1 / (1 + e^(-0.1 * (timeSec - 15)))
     Реалізація (рядки 300-305 додатку В):
     
float calculateConfidence(long votingTimeMs) {
  double timeSec = votingTimeMs / 1000.0;
  double confidence = 1.0 / (1.0 + exp(-0.1 * (timeSec - 15.0)));
  return (float)confidence;
}
     При t = 15 сек → confidence = 0.5 (точка перегину). При t < 15 сек → confidence низька (швидкий імпульсивний вибір). При t > 15 сек → confidence зростає (обдумане вибирання). Метрика використовується для визначення чи це справжній користувач чи автоматизований процес.
     3.2.2 Функція calculateAnomalyScore()
     Виявляє дивну активність пристрою через Z-score статистичний метод. Порівнює час голосування з очікуваним значенням:
     Формула: zScore = |votingTime - 15000| / 5000
     Реалізація (рядки 307-311 додатку В):

float calculateAnomalyScore(long votingTimeMs) {
  double expectedTime = 15000.0;
  double stdDev = 5000.0;
  double zScore = abs((votingTimeMs - expectedTime) / stdDev);
  return (float)zScore;
}
     Інтерпретація:
     • z < 1.0: нормальна активність
     • z = 1.0-2.0: незвичайна активність
     • z = 2.0-3.0: підозріла активність (SUSPICIOUS)
     • z > 3.0: дуже дивна активність (REJECTED)
     Метрика дозволяє виявити та попередити про потенційних ботів або технічні помилки.
     3.2.3 Функція calculateEntropy()
     Розраховує ентропію Шеннона — міру невизначеності при виборі:
     Формула: H = -(p*log2(p) + (1-p)*log2(1-p))
     Реалізація (рядки 313-320 додатку В):
     
float calculateEntropy(long votingTimeMs) {
  double normalized = min(votingTimeMs / 30000.0, 1.0);
  double p = normalized;
  if (p <= 0.0 || p >= 1.0) return 0.0;
  double entropy = -(p * (log(p) / log(2.0)) + 
                     (1 - p) * (log(1 - p) / log(2.0)));
  return (float)entropy;
}
     Низька ентропія вказує на впевнений швидкий вибір, висока ентропія — на довгі коливання та невизначеність.
     3.2.4 Функція computeVoteMetrics()
     Композує всі три метрики в єдину структуру VoteMetrics та визначає статус валідації:
     Реалізація (рядки 322-337 додатку В):
     
void computeVoteMetrics(long votingTimeMs) {
  currentMetrics.votingTimeMs = votingTimeMs;
  currentMetrics.confidence = calculateConfidence(votingTimeMs);
  currentMetrics.anomalyScore = calculateAnomalyScore(votingTimeMs);
  currentMetrics.entropy = calculateEntropy(votingTimeMs);
  
  if (currentMetrics.anomalyScore > config.anomalyThreshold * 2) {
    currentMetrics.validationStatus = "REJECTED";
  } else if (currentMetrics.confidence < 0.3 || 
             currentMetrics.anomalyScore > config.anomalyThreshold) {
    currentMetrics.validationStatus = "SUSPICIOUS";
  } else {
    currentMetrics.validationStatus = "APPROVED";
  }
}
     • APPROVED: confidence > 0.3 ТА anomalyScore < threshold → голос приймається
     • SUSPICIOUS: confidence ≤ 0.3 АБО anomalyScore ≥ threshold → голос підозрілий
     • REJECTED: anomalyScore > threshold * 2 → голос відхиляється
     3.2.5 Функція handleRating()
     Обробляє процес голосування. Показує рейтинг-опитування, стартує таймер, читає стан пінів кнопок, чекає натискання однієї з 5 кнопок:
     Реалізація (рядки 248-298 додатку В):
     
void handleRating() {
  displayPoll();
  
  unsigned long startTime = millis();
  int rating = 0;
  
  while (millis() - startTime < config.displayTimeoutMs) {
    if (digitalRead(BTN_RATING_1) == LOW) {
      rating = 1;
      break;
    }
    // ... інші кнопки ...
    delay(50);
  }
  
  if (rating > 0) {
    long votingTime = millis() - startTime;
    computeVoteMetrics(votingTime);
    sendVote(rating);
  }
}
     3.2.6 Функція syncWithServer()
     Синхронізується з сервером кожні 60 секунд. Робить GET запит до /api/iot/sync/{deviceId}, отримує конфіг:
     Реалізація (рядки 107-150 додатку В):
     
void syncWithServer() {
  if (WiFi.status() != WL_CONNECTED) return;
  
  String url = String(SERVER_BASE_URL) + "/iot/sync/" + config.deviceId;
  HTTPClient http;
  if (http.begin(client, url)) {
    int httpCode = http.GET();
    
    if (httpCode == 200) {
      // Парсування JSON та оновлення config
      config.pollIntervalMs = data["config"]["pollIntervalMs"];
      config.confidenceThreshold = data["config"]["confidenceThreshold"];
      // ...
      saveSettings();
    }
  }
}
     3.2.7 Функція getPollFromServer()
     Запитує активні опитування кожні 30 секунд:
     Реалізація (рядки 152-215 додатку В):
     
void getPollFromServer() {
  String url = String(SERVER_BASE_URL) + "/polls?status=ACTIVE";
  HTTPClient http;
  if (http.begin(client, url)) {
    int httpCode = http.GET();
    
    if (httpCode == 200) {
      DynamicJsonDocument doc(4096);
      deserializeJson(doc, payload);
      
      if (doc.is<JsonArray>() && arr.size() > 0) {
        JsonObject poll = arr[0];
        currentPoll.id = poll["id"];
        currentPoll.title = poll["title"];
        currentPoll.maxRating = poll["rating_max_scale"] | 5;
        currentPoll.isActive = (poll["status"] == "ACTIVE");
      }
    }
  }
}
     3.3 Функції Налаштування IoT Клієнта
     3.3.1 connectWiFi()
     Забезпечує встановлення з'єднання з WiFi мережею. Перевіряє чи вже підключено, якщо ні — викликає WiFi.begin(), чекає максимум 20 спроб:
     Реалізація (рядки 78-105 додатку В):
     
void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  
  Serial.print("🔌 Підключення до WiFi");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅ WiFi підключено!");
  }
}
     3.3.2 loadSettings() та saveSettings()
     Функції для управління конфігурацією у невилітній пам'яті EEPROM. loadSettings() завантажує параметри з дефолтними значеннями як fallback:
     Реалізація loadSettings() (рядки 64-77 додатку В):
     
void loadSettings() {
  preferences.begin("kiosk-config", false);
  config.deviceId = preferences.getString("deviceId", DEVICE_ID);
  config.pollIntervalMs = preferences.getULong("pollInterval", 30000);
  config.displayTimeoutMs = preferences.getULong("displayTimeout", 120000);
  config.confidenceThreshold = preferences.getFloat("confThreshold", 0.6);
  config.anomalyThreshold = preferences.getFloat("anomThreshold", 2.5);
  // ...
}
     Реалізація saveSettings() (рядки 97-104 додатку В):
     
void saveSettings() {
  preferences.putString("deviceId", config.deviceId);
  preferences.putULong("pollInterval", config.pollIntervalMs);
  preferences.putFloat("confThreshold", config.confidenceThreshold);
  // ...
  Serial.println("✅ Конфіг збережено у Flash");
}
     3.3.3 sendVote()
     Відправляє голос на сервер. Формує JSON об'єкт з рейтингом та метриками:
     Реалізація (рядки 339-376 додатку В):
     
void sendVote(int rating) {
  if (WiFi.status() != WL_CONNECTED) {
    digitalWrite(LED_ERROR, HIGH);
    delay(500);
    digitalWrite(LED_ERROR, LOW);
    return;
  }
  
  DynamicJsonDocument doc(512);
  doc["iotDeviceId"] = config.deviceId;
  doc["pollId"] = currentPoll.id;
  doc["rating"] = rating;
  doc["votingTimeMs"] = currentMetrics.votingTimeMs;
  doc["confidence"] = currentMetrics.confidence;
  doc["anomalyScore"] = currentMetrics.anomalyScore;
  doc["entropy"] = currentMetrics.entropy;
  doc["validationStatus"] = currentMetrics.validationStatus;
  
  String jsonData;
  serializeJson(doc, jsonData);
  
  HTTPClient http;
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  
  int httpCode = http.POST(jsonData);
  
  if (httpCode == 201 || httpCode == 200) {
    Serial.println("✅ Голос відправлено успішно!");
    digitalWrite(LED_VOTE_OK, HIGH);
    delay(1000);
    digitalWrite(LED_VOTE_OK, LOW);
  } else {
    digitalWrite(LED_ERROR, HIGH);
    delay(500);
    digitalWrite(LED_ERROR, LOW);
  }
}
     При статусі 200-201 — вмикає зелений LED на 1 сек (успіх), інакше — червоний LED на 500мс (помилка).
     3.4 Ініціалізація та Основний Цикл Програми
     3.4.1 Функція setup()
     Ініціалізує систему один раз при включенні пристрою. Налаштовує піни, завантажує конфіг, підключається до WiFi:
     Реалізація (рядки 380-400 додатку В):
     
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  pinMode(BTN_RATING_1, INPUT_PULLUP);
  pinMode(BTN_RATING_2, INPUT_PULLUP);
  pinMode(BTN_RATING_3, INPUT_PULLUP);
  pinMode(BTN_RATING_4, INPUT_PULLUP);
  pinMode(BTN_RATING_5, INPUT_PULLUP);
  
  pinMode(LED_VOTE_OK, OUTPUT);
  pinMode(LED_ERROR, OUTPUT);
  digitalWrite(LED_VOTE_OK, LOW);
  digitalWrite(LED_ERROR, LOW);
  
  Serial.println("\n🎯 IoT Рейтинг-голосування");
  Serial.println("════════════════════════════════\n");
  
  loadSettings();
  connectWiFi();
  syncWithServer();
  getPollFromServer();
  
  Serial.println("✅ Система готова!\n");
}
     3.4.2 Функція loop()
     Крутиться нескінченно. На кожній ітерації перевіряє WiFi, синхронізується кожні 60 сек, запитує опитування кожні 30 сек, обробляє голосування якщо активне:
     Реалізація (рядки 402-427 додатку В):
     
void loop() {
  connectWiFi();
  
  unsigned long currentTime = millis();
  
  // Синхронізація кожні 60 сек
  if (currentTime - lastSyncTime >= SYNC_INTERVAL) {
    syncWithServer();
    lastSyncTime = currentTime;
  }
  
  // Запит опитування кожні 30 сек
  if (currentTime - lastPollFetchTime >= POLL_FETCH_INTERVAL) {
    getPollFromServer();
    lastPollFetchTime = currentTime;
  }
  
  // Обробка голосування якщо активне
  if (currentPoll.isActive) {
    handleRating();
    delay(2000);
    getPollFromServer();
  } else {
    Serial.println("⏳ Очікування опитування...");
    delay(5000);
  }
}
     Таймери реалізовані через millis() без блокування (non-blocking) щоб система завжди залишалася відзивчивою.
     


     4 ВИСНОВКИ
     У ході виконання лабораторної роботи було успішно розроблено та реалізовано повнофункціональний IoT клієнт для системи рейтинг-голосувань на базі ESP32. Система включає:
     Бізнес-логіка:
• Три математичні метрики для оцінки якості голосів (Confidence, Anomaly Score, Entropy)
• Автоматична класифікація голосів на APPROVED/SUSPICIOUS/REJECTED на основі метрик
• Сигмоїдна функція для впевненості користувача
• Z-score метод для виявлення аномалій та ботів
     Функції налаштування:
• Динамічна синхронізація конфігурації з сервером
• Управління конфігурацією у EEPROM з можливістю оновлення без перезавантаження
• Гнучкі пороги валідації для адаптації до різних сценаріїв
     Взаємодія:
• REST API для синхронізації, запиту опитувань та відправки голосів
• Real-time LED індикація результатів (успіх/помилка)
• Детальне логування процесу в серійний порт
     Архітектура побудована за принципом модульності та розширюваності, дозволяючи легко додавати нові типи голосувань чи метрик без змін основної логіки. Система готова для інтеграції з веб-клієнтом та подальшого розширення функціональності.
     
     

     ДОДАТОК А
     ВІДЕОЗАПИС
     https://www.youtube.com/watch?v=Lh7U7EcKOpY
     Хронологічний опис відеозапису:
     00:00 – Представлення
     00:12 – Завдання лабораторної роботи
     01:35 – Структури
     01:58 – Підключення до WiFi (connectWiFi)
     02:20 – Синхронізація з сервером (syncWithServer)
     02:34 – Отримання опитування (getPollFromServer)
     03:30 – Вивід опитування на екран (displayPoll)
     03:50 – Обробка рейтингу та кнопок (handleRating)
     04:10 – Математика
     04:48 – Відправка голосу на сервер (sendVote)
     05:10 – Ініціалізація системи (setup) & (loop)
     04:30 – Трішки про сервер
     05:45 – SQL запит у БД
     06:35 – Wokwi схема та diagram.json
     06:45 – Swagger API
     07:20 – Підготовка до live-тесту
     07:42 – Тестування

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 — UML діаграма прецедентів IoT клієнта


Рисунок Б.2 — UML діаграма діяльності IoT клієнта


ДОДАТОК В
Специфікація API
IoT Endpoints
1. GET /api/iot/sync/{deviceId} - Опис: Синхронізація конфігурації IoT пристрою
2. POST /api/iot/votes - Опис: Реєстрація голосу від IoT пристрою


