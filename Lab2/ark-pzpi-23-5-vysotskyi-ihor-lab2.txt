МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ






Звіт
з лабораторної роботи № 2
з дисципліни
«Аналіз та рефакторинг коду»









Виконав:	Перевірив:
ст. гр. ПЗПІ-23-5	ст. викладач кафедри ПІ
Висоцький І. О.	Сокорчук Ігор Петрович












2025

1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень115.12.20250.1Створено розділ "Опис виконаної роботи"216.11.20251.0Додано всі розділи, діаграми та специфікація API
      



     2 ЗАВДАННЯ
     1. Розробити будову програмної системи. 
     2. Створити UML діаграму прецедентів для серверної частини системи. 
     3. Створити ER діаграму даних. 
     4. Розробити базу даних (БД) програмної системи. 
     5. Створити діаграму структури БД. 
     6. Розробити функції роботи з БД (ORM або CoRM тощо). 
     7. Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами. 
     8. Створити специфікацію розробленого API. 
     9. Створити програмну реалізацію розробленого API та функцій роботи з БД. 
     10. Перевірити роботу створеного програмного коду серверної частини системи. 
     11. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main. 
     12. Створити відеозапис тривалістю 7-9 хвилин з демонстрацією перевірки (тестування) описаної у розділі 3.1 Vision & Scope функціональності серверної частини. 
     13. Завантажити створений відеозапис у свій канал для облікового запису студента в домені nure.ua на YouTube. 
     14. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео на YouTube. 
     15. Створити звіт до лабораторної роботи. 
     16. Вказати у звіті посилання на створений відеозапис на YouTube 
     17. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua 
     18. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.

     3 ОПИС ВИКОНАНОЇ РОБОТИ
     Архітектура програмної системи
     Програмна система реалізована як серверна частина у вигляді REST API-додатку на базі Java 21 та Spring Boot 3.5.7. Сервер взаємодіє з базою даних PostgreSQL, розміщеною на хмарній платформі NeonDB, забезпечуючи надійність та масштабованість.
     Архітектура побудована за принципами чистого кодування з чітким поділом відповідальності між рівнями: контролери обробляють HTTP-запити, репозиторії здійснюють взаємодію з БД через JPA/Hibernate ORM, а Entity класи моделюють дані. WebSocket інтеграція забезпечує real-time трансляцію результатів голосувань усім підключеним клієнтам. Spring Security застосовується для аутентифікації адміністраторів через JWT-токени та управління ролями доступу (ROLE_ADMIN).
     Моделювання даних та база даних
     Модель даних розроблена з дотриманням третьої нормальної форми, забезпечуючи цілісність та ефективність зберігання інформації. Основні сутності системи включають:
     • Admins — адміністратори системи з реєстрацією через email та хешуванням пароля
     • DeviceFingerprints — унікальні відбитки пристроїв для запобігання повторному голосуванню
     • Polls — голосування з підтримкою різних типів (SINGLE, MULTIPLE, RATING, OPEN)
     • PollOptions — варіанти відповідей для кожного голосування
     • Votes — записи про голоси учасників з прив'язкою до пристрою та часу
     • AdminLogs — логування всіх дій адміністраторів для аудиту
     Зв'язки між сутностями реалізовано через зовнішні ключі з каскадним видаленням, що забезпечує автоматичне очищення пов'язаних даних при видаленні основного запису.
     Реалізація ORM та взаємодія з БД
     Для взаємодії з базою даних використовується Spring Data JPA з Hibernate ORM, що забезпечує об'єктно-реляційне відображення. Entity класи (Admin, DeviceFingerprint, Poll, PollOption, Vote, AdminLog) анотовані за допомогою JPA-анотацій (@Entity, @Table, @Column, @ManyToOne, @OneToMany), що дозволяє автоматичне генерування SQL-запитів.
     Репозиторії (AdminRepository, DeviceFingerprintRepository, PollRepository, PollOptionRepository, VoteRepository, AdminLogRepository) розширюють JpaRepository, надаючи стандартні CRUD операції та можливість визначення користувальницьких запитів через методи з підписом або @Query анотаціями.
     Приклад підключення до БД та використання Hibernate:
// Конфігурація в application.properties
spring.datasource.url=jdbc:postgresql://...
spring.datasource.username=...
spring.datasource.password=...
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=none

// Використання Repository для отримання даних
@Autowired
private PollRepository pollRepository;

public ResponseEntity<List<Poll>> getPollsByStatus(String status) {
    return ResponseEntity.ok(pollRepository.findByStatus(status));
}
     Entity класи включають:
     • Первинні ключі типу UUID для глобальної унікальності
     • Поля з відповідними типами даних та обмеженнями (nullable, unique, length)
     • Зв'язки між сутностями через @ManyToOne та @OneToMany анотаціями
     • Відпалювачі (triggers) на рівні БД для автоматичного оновлення last_seen та логування дій
     REST API та специфікація
     REST API розроблено як набір HTTP-ендпоінтів, згрупованих за функціональністю:
     API Адміністраторів (/api/admins):
     • GET /api/admins — отримати список всіх адміністраторів
     • GET /api/admins/{id} — отримати адміністратора за ID
     • POST /api/admins — створити нового адміністратора
     • PUT /api/admins/{id} — оновити адміністратора
     • DELETE /api/admins/{id} — видалити адміністратора
     API Голосувань (/api/polls):
     • GET /api/polls — отримати всі голосування
     • GET /api/polls/{id} — отримати голосування за ID
     • GET /api/polls/status/{status} — фільтрування за статусом
     • POST /api/polls — створити нове голосування
     • PUT /api/polls/{id} — оновити голосування
     • DELETE /api/polls/{id} — видалити голосування
     API Варіантів відповідей (/api/poll-options):
     • GET /api/poll-options — отримати всі варіанти
     • POST /api/poll-options — створити варіант
     • DELETE /api/poll-options/{id} — видалити варіант
     API Голосів (/api/votes):
     • GET /api/votes — отримати всі голоси
     • POST /api/votes — створити новий голос
     • DELETE /api/votes/{id} — видалити голос
     API Відбитків пристроїв (/api/device-fingerprints):
     • GET /api/device-fingerprints — отримати всі відбитки
     • POST /api/device-fingerprints — створити відбиток
     • GET /api/device-fingerprints/blocked — отримати заблоковані пристрої
     API Логів (/api/admin-logs):
     • GET /api/admin-logs — отримати всі логи
     • GET /api/admin-logs/action/{action} — фільтрування за типом дії
     • GET /api/admin-logs/target-type/{targetType} — фільтрування за типом цілі
     Для кожного ендпоінту визначено:
     • Метод HTTP (GET, POST, PUT, DELETE)
     • Параметри запиту та шляху
     • Тіло запиту (requestBody) з JSON-схемою
     • Очікувані відповіді (200, 201, 400, 401, 403, 404)
     • Схеми даних компонентів (Components/Schemas)
     Документація API та Swagger UI
     Специфікація API автоматично генерується з використанням бібліотеки Springdoc OpenAPI (версія 2.7.0) та доступна через інтерактивний Swagger UI за адресою http://localhost:8080/swagger-ui.html.
     Конфігурація Swagger реалізована у класі SwaggerConfig (рядки 1-25):
// SwaggerConfig.java
1  @Configuration
2  public class SwaggerConfig {
3  
4      @Bean
5      public OpenAPI customOpenAPI() {
5          return new OpenAPI()
7              .info(new Info()
8                  .title("Система швидких голосувань - API")
9                  .description("REST API для системи швидкого створення та проведення голосувань з real-time аналітикою")
10                 .version("1.0.0")
11                 .contact(new Contact()
12                     .name("Висоцький Ігор")
13                     .email("support@polls.com")
14                     .url("https://github.com/vysotskyi-ihor"))
15                 .license(new License()
16                     .name("MIT License")
17                     .url("https://opensource.org/licenses/MIT")))
18             .servers(List.of(
19                 new Server()
20                     .url("http://localhost:8080")
21                     .description("Local Environment"),
22                 new Server()
23                     .url("https://api.polls.com")
24                     .description("Production Environment")
25             ));
26     }
27 }
     Кожен контролер анотований за допомогою @Tag та @Operation, що забезпечує автоматичне створення документації. Приклад з PollController:
@RestController
@RequestMapping("/api/polls")
@Tag(name = "Polls", description = "Управління голосуваннями")
public class PollController {
    
    @GetMapping
    @Operation(summary = "Отримати всі голосування")
    public ResponseEntity<List<Poll>> getAllPolls() { ... }
    
    @PostMapping
    @Operation(summary = "Створити нове голосування")
    public ResponseEntity<Poll> createPoll(@RequestBody Poll poll) { ... }
}
     Swagger UI автоматично генерує інтерактивну документацію з:
     • Повною специфікацією усіх ендпоінтів
     • Прикладами запитів та відповідей для кожної операції
     • JSON схемами для усіх сутностей (Poll, Admin, Vote, DeviceFingerprint, PollOption, AdminLog)
     • Можливістю прямого тестування API з браузера
     Усі операції мають правильні HTTP статус-коди: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 404 Not Found — що забезпечує коректну обробку помилок на стороні клієнта.
     Технологічний стек та залежності
     Розробка програмної системи здійснена із використанням сучасного технологічного стеку для Java-розробки. Основою служить Java 21 та Spring Boot 3.5.7, що забезпечує надійність, масштабованість та чіткість архітектури.
     Основні залежності проєкту (pom.xml):
<!-- Spring Data JPA для ORM -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Spring Web для REST API -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring WebSocket для real-time -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>

<!-- PostgreSQL драйвер -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.7.1</version>
    <scope>runtime</scope>
</dependency>

<!-- Springdoc OpenAPI для Swagger UI -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.7.0</version>
</dependency>
     Налаштування проєкту:
     Проєкт налаштовується через файли:
     • application.properties — конфігурація БД, JPA, Swagger та сервера
     • pom.xml — опис залежностей, версій та плаґінів Maven
     • SwaggerConfig.java — конфігурація OpenAPI специфікації
     Система розробляється з дотриманням best practices Java розробки: використання анотацій для конфігурації, dependency injection через Spring, правильна структура проєкту (controller → repository → entity).
     Засоби розробки та інструменти:
     • IntelliJ IDEA — IDE для розробки
     • Maven — система управління залежностями та збірки
     • Git/GitHub — контроль версій та розповсюдження коду
     • Postman або Swagger UI — тестування API
     • PostgreSQL/NeonDB — база даних у хмарі


     4 ВИСНОВКИ
     У ході виконання лабораторної роботи було успішно розроблено та реалізовано повноцінну серверну частину системи швидких голосувань з real-time аналітикою. Створено релаціну базу даних з шістьма основними сутностями, нормалізовану до третьої нормальної форми, що забезпечує цілісність та ефективність зберігання даних.
     Реалізовано REST API з дев'ятьма групами ендпоінтів, що охоплюють управління голосуваннями, варіантами, голосами, відбитками пристроїв та логами адміністраторів. Використання Spring Data JPA та Hibernate забезпечує надійну та типобезпечну взаємодію з базою даних. Конфігурація Swagger UI дозволяє легко тестувати та документувати всі ендпоінти без додаткових інструментів.
     Система готова до інтеграції з клієнтською частиною (веб та мобільною) та розширення функціональності на наступних етапах розробки (лаба 3 — бізнес-логіка та адміністрування, лаба 4 — IoT клієнт).
     

     ДОДАТОК А
     ВІДЕОЗАПИС
     https://www.youtube.com/watch?v=bvSZw1sqRJA
     Хронологічний опис відеозапису:
     00:00 — Представлення
     00:15 — Завдання лабораторної роботи
     00:45 — Пояснення схеми бази даних
     01:30 — Підключення до бази даних
     02:04 — JPA Entity (приклад Poll)
     03:30 — Специфікація REST API
     04:30 — Наповнення БД тестовими даними
     03:40 — Тестування API
     05:40 — Перевірка повторного голосування
     06:05 — Адмін-функції: закриття голосування
     06:30 — Адмін-функції: блокування пристрою
     06:55 — Адмін-функції: перегляд логів
     07:15 — Адмін-функції: видалення голосування
     13:13 — Висновки
     

ДОДАТОК Б
Графічні матеріали

Рисунок 1 — UML діаграма прецедентів

Рисунок 2 — ER діаграма

Рисунок 3 — Діаграма структури БД

Рисунок 4 — Специфікація розробленого API


ДОДАТОК В
Специфікація API
     Base URL: http://localhost:8080	
     
     Опитування (Polls)
     Метод     Endpoint     Опис     GET     /api/polls     Отримати всі опитування     POST     /api/polls     Створити нове опитування     GET     /api/polls/{id}     Отримати опитування по ID     PUT     /api/polls/{id}     Оновити опитування     DELETE     /api/polls/{id}     Видалити опитування     GET     /api/polls/status/{status}     Отримати опитування за статусом     Відповідь (Poll):
     • id (UUID) — унікальний ідентифікатор
     • title (string) — заголовок
     • question (string) — питання
     • type (string) — тип опитування
     • status (string) — статус (активне/закрите)
     • multipleAnswers (boolean) — дозволити кілька відповідей
     • showResults (boolean) — показувати результати
     • createdAt (ISO 8601) — дата створення
     • closedAt (ISO 8601) — дата закриття
     • closedByAdmin (Admin) — адміністратор, який закрив опитування
     • organizerFingerprint (DeviceFingerprint) — відбиток організатора
     
     Варіанти опитування (Poll Options)
     Метод     Endpoint     Опис     GET     /api/poll-options     Отримати всі варіанти     POST     /api/poll-options     Створити новий варіант     GET     /api/poll-options/{id}     Отримати варіант по ID     DELETE     /api/poll-options/{id}     Видалити варіант     Параметри POST:
     • pollId (UUID) — ID опитування
     • text (string) — текст варіанту
     • orderNum (number) — порядковий номер
     Відповідь (PollOption):
     • id (UUID)
     • text (string)
     • orderNum (number)
     
     Голоси (Votes)
     Метод     Endpoint     Опис     GET     /api/votes     Отримати всі голоси     POST     /api/votes     Створити новий голос     GET     /api/votes/{id}     Отримати голос по ID     DELETE     /api/votes/{id}     Видалити голос     Параметри POST:
     • poll.id (UUID) — ID опитування
     • option.id (UUID) — ID варіанту
     • fingerprint.id (UUID) — ID відбитка пристрою
     • textAnswer (string) — текстова відповідь (опціонально)
     Відповідь (Vote):
     • id (UUID)
     • poll (Poll) — дані опитування
     • option (PollOption) — вибраний варіант
     • fingerprint (DeviceFingerprint) — відбиток голосуючого
     • votedAt (ISO 8601) — час голосування
     • textAnswer (string) — текстова відповідь
     
     Адміністратори (Admins)
     Метод     Endpoint     Опис     GET     /api/admins     Отримати всіх адміністраторів     POST     /api/admins     Створити нового адміністратора     GET     /api/admins/{id}     Отримати адміністратора по ID     PUT     /api/admins/{id}     Оновити адміністратора     DELETE     /api/admins/{id}     Видалити адміністратора     Параметри POST/PUT:
     • email (string) — email
     • passwordHash (string) — хеш паролю
     • name (string) — ім'я
     • isActive (boolean) — активний/неактивний
     Відповідь (Admin):
     • id (UUID)
     • email (string)
     • passwordHash (string)
     • name (string)
     • isActive (boolean)
     • createdAt (ISO 8601)
     • lastLoginAt (ISO 8601)
     
     Відбитки пристроїв (Device Fingerprints)
     Метод     Endpoint     Опис     GET     /api/device-fingerprints     Отримати всі відбитки     POST     /api/device-fingerprints     Створити новий відбиток     GET     /api/device-fingerprints/{id}     Отримати відбиток по ID     DELETE     /api/device-fingerprints/{id}     Видалити відбиток     GET     /api/device-fingerprints/blocked     Отримати заблоковані відбитки     Параметри POST:
     • fingerprintHash (string) — хеш відбитка
     • ip (string) — IP-адреса
     • userAgent (string) — User Agent браузера
     Відповідь (DeviceFingerprint):
     • id (UUID)
     • fingerprintHash (string)
     • ip (string)
     • userAgent (string)
     • createdAt (ISO 8601)
     • lastSeen (ISO 8601) — останній раз бачено
     • isBlocked (boolean)
     • blockReason (string)
     • blockedByAdmin (Admin)
     • blockedAt (ISO 8601)
     
     Логи адміністраторів (Admin Logs)
     Метод     Endpoint     Опис     GET     /api/admin-logs     Отримати всі логи     GET     /api/admin-logs/{id}     Отримати лог по ID     GET     /api/admin-logs/target-type/{targetType}     Логи за типом цілі     GET     /api/admin-logs/action/{action}     Логи за типом дії     Відповідь (AdminLog):
     • id (UUID)
     • admin (Admin) — адміністратор, який виконав дію
     • action (string) — тип дії (CREATE, UPDATE, DELETE, BLOCK тощо)
     • targetType (string) — тип об'єкта (POLL, VOTE, FINGERPRINT тощо)
     • targetId (UUID) — ID об'єкта
     • description (string) — описання дії
     • createdAt (ISO 8601)
     
     Коди відповідей
     • 200 OK — успішний запит
     • 400 Bad Request — невірні параметри
     • 404 Not Found — ресурс не знайдений
     • 500 Internal Server Error — помилка сервера
     Контакт
     Email: support@polls.com
     


