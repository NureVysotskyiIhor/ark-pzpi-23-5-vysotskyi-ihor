МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ






Звіт
з лабораторної роботи № 3
з дисципліни
«Аналіз та рефакторинг коду»









Виконав:	Перевірив:
ст. гр. ПЗПІ-23-5	ст. викладач кафедри ПІ
Висоцький І. О.	Сокорчук Ігор Петрович












2025

1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень122.12.20250.1Створено розділ "Опис виконаної роботи"
      



     2 ЗАВДАННЯ
     1. Розробити бізнес логіку серверної частини програмної системи 
     2. Розробити функції адміністрування серверної частини програмної системи 
     3. Створити програмну реалізацію бізнес логіки та функцій адміністрування 
     4. Перевірити роботу серверної частини системи 
     5. Завантажити програмний код у GitHub репозиторій 
     6. Створити відеозапис демонстрації функціональності 
     7. Експортувати звіт у PDF та текстовий файл

     3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Архітектура бізнес-логіки серверної частини
     Бізнес-логіка серверної частини реалізована у вигляді окремих сервісних класів, кожен з яких відповідає за конкретну функціональність. Архітектура побудована за принципом розділення відповідальності (SoC), що забезпечує модульність та легкість тестування.
     3.1.1 Статистика голосувань та математичні розрахунки
     PollService — основний сервіс для управління голосуваннями та розрахунку статистики. Повний цикл голосування зображено на рисунку Б.5, а процес розрахунку статистики — на рисунку Б.3.
     Розрахунок математичних показників розподілу голосів (рядки 236–260):
     
     // МАТЕМАТИКА: Середнє значення (Mean)
     double sum = ratingValues.stream()
             .mapToDouble(Double::doubleValue)
             .sum();
     double mean = sum / ratingValues.size();
     metrics.put("mean", Math.round(mean * 100.0) / 100.0);
     
     // МАТЕМАТИКА: Стандартне відхилення (Standard Deviation)
     double variance = ratingValues.stream()
             .mapToDouble(value -> Math.pow(value - mean, 2))
             .average()
             .orElse(0.0);
     double stdDeviation = Math.sqrt(variance);
     metrics.put("stdDeviation", Math.round(stdDeviation * 100.0) / 100.0);
     
     // МАТЕМАТИКА: Коефіцієнт варіації
     double coefficientOfVariation = (mean != 0)
             ? (stdDeviation / mean) * 100
             : 0.0;
     metrics.put("coefficientOfVariation", 
             Math.round(coefficientOfVariation * 100.0) / 100.0);
     Метод визначає статистичні параметри розподілу голосів за варіантами, необхідні для аналізу репрезентативності результатів.
     Розрахунок статистики голосувань (рядки 196–225):
     
     // МАТЕМАТИКА: Розрахунок відсотків
     long votesForOption = votes.stream()
             .filter(v -> v.getOption() != null && 
                     v.getOption().getId().equals(option.getId()))
             .count();
     
     // МАТЕМАТИКА: Формула відсотку = (голоси / всього) * 100
     double percentage = totalVotes > 0
             ? (votesForOption * 100.0) / totalVotes
             : 0.0;
     
     optionData.put("optionId", option.getId());
     optionData.put("optionText", option.getText());
     optionData.put("votes", votesForOption);
     optionData.put("percentage", Math.round(percentage * 100.0) / 100.0);
     3.1.2 Перевірка дублів та виявлення аномалій активності
     VoteService — управління голосами з вбудованою перевіркою на повторне голосування та виявлення аномальної активності. Процес реєстрації голосу показаний на діаграмі послідовності (див. рисунок Б.1).
     Реєстрація голосу з валідацією (рядки 50–75):
     
// БІЗНЕС-ЛОГІКА: Перевірка на повторне голосування
if (hasAlreadyVoted(pollId, fingerprintId)) {
    System.out.println("❌ Already voted");
    return null;
}

// БІЗНЕС-ЛОГІКА: Перевірка блокування пристрою
DeviceFingerprint fingerprint = deviceFingerprintRepository
        .findById(fingerprintId).orElse(null);
if (fingerprint == null || fingerprint.getIsBlocked()) {
    System.out.println("❌ Device blocked");
    return null;
}

// БІЗНЕС-ЛОГІКА: Запис голосу та трансляція через WebSocket
Vote savedVote = voteRepository.save(vote);
webSocketBroadcaster.broadcastPollResults(pollId, stats);
Виявлення аномалій активності (рядки 121–132). Детальний сценарій виявлення показаний на рисунку Б.4:

// МАТЕМАТИКА: Розрахунок аномалії за Z-score методом
public double calculateAnomalyScore(UUID fingerprintId, UUID pollId) {
    long votesFromDevice = countVotesFromFingerprint(fingerprintId);
    
    // МАТЕМАТИКА: Середнє значення голосів з одного пристрою
    double averageVotesPerDevice = allFingerprints.stream()
            .mapToLong(fp -> voteRepository.findByFingerprint(fp).size())
            .average()
            .orElse(1.0);
    
    double anomalyScore = votesFromDevice / averageVotesPerDevice;
    return Math.round(anomalyScore * 100.0) / 100.0;
}
3.1.3 Генерування та управління device fingerprints
DeviceFingerprintService — управління унікальними відбитками пристроїв та блокуванням.
Генерування SHA-256 хешу відбитка пристрою (рядки 43–64):

// МАТЕМАТИКА: SHA-256 хешування для унікальної ідентифікації
public String generateFingerprintHash(String ip, String userAgent) {
    try {
        String combined = ip + "|" + userAgent + "|" 
                + System.nanoTime();
        
        // МАТЕМАТИКА: SHA-256 алгоритм хешування
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = digest.digest(
                combined.getBytes(StandardCharsets.UTF_8));
        
        // Конвертація в hex-строку
        StringBuilder hexString = new StringBuilder();
        for (byte b : hashBytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    } catch (Exception e) {
        throw new RuntimeException("Fingerprint generation failed", e);
    }
}
Отримання або створення відбитка (рядки 67–87). Процес валідації пристрою детально описаний на рисунку Б.7:

public DeviceFingerprint getOrCreateFingerprint(String ip, 
        String userAgent) {
    String fingerprintHash = generateFingerprintHash(ip, userAgent);
    
    Optional<DeviceFingerprint> existing = 
            deviceFingerprintRepository
            .findByFingerprintHash(fingerprintHash);
    
    if (existing.isPresent()) {
        DeviceFingerprint fp = existing.get();
        fp.setLastSeen(LocalDateTime.now());
        return deviceFingerprintRepository.save(fp);
    }
    
    // Створення нового відбитка
    DeviceFingerprint newFingerprint = new DeviceFingerprint();
    newFingerprint.setFingerprintHash(fingerprintHash);
    newFingerprint.setIp(ip);
    newFingerprint.setUserAgent(userAgent);
    newFingerprint.setCreatedAt(LocalDateTime.now());
    newFingerprint.setIsBlocked(false);
    
    return deviceFingerprintRepository.save(newFingerprint);
}

3.2 Функції адміністрування серверної частини
3.2.1 Резервне копіювання та відновлення бази даних
BackupService — управління резервними копіями БД з використанням утиліт PostgreSQL.
Створення резервної копії (рядки 50–95):

// БІЗНЕС-ЛОГІКА: Резервне копіювання БД через pg_dump
public String createBackup() {
    try {
        Files.createDirectories(Paths.get(backupDir));
        
        String timestamp = LocalDateTime.now()
                .format(dateFormatter);
        String filename = "polls_backup_" + timestamp + ".sql";
        String filepath = backupDir + "/" + filename;
        
        DbInfo db = parseJdbcUrl(dbUrl);
        
        // МАТЕМАТИКА: Командна строка для pg_dump
        ProcessBuilder pb = new ProcessBuilder(
            "pg_dump",
            "-h", db.host(),
            "-p", db.port(),
            "-U", dbUsername,
            "-F", "plain",
            dbName
        );
        
        Map<String, String> env = pb.environment();
        env.put("PGPASSWORD", dbPassword);
        
        pb.redirectOutput(new File(filepath));
        Process process = pb.start();
        int exitCode = process.waitFor();
        
        if (exitCode == 0) {
            long fileSize = Files.size(Paths.get(filepath));
            logger.info("✅ Резервна копія успішно створена: {}", filepath);
            return filepath;
        }
    } catch (Exception e) {
        logger.error("❌ Помилка при створенні резервної копії", e);
        throw new RuntimeException("Backup failed", e);
    }
}
Відновлення з резервної копії (рядки 118–155):

// БІЗНЕС-ЛОГІКА: Відновлення БД з резервної копії через psql
public boolean restoreBackup(String backupFilepath) {
    try {
        if (!Files.exists(Paths.get(backupFilepath))) {
            logger.error("❌ Файл не знайдено: {}", backupFilepath);
            return false;
        }
        
        DbInfo db = parseJdbcUrl(dbUrl);
        
        // МАТЕМАТИКА: Командна строка для psql
        ProcessBuilder pb = new ProcessBuilder(
            "psql",
            "-h", db.host(),
            "-p", db.port(),
            "-U", dbUsername,
            "-d", db.dbName(),
            "-f", backupFilepath
        );
        
        Map<String, String> env = pb.environment();
        env.put("PGPASSWORD", dbPassword);
        
        Process process = pb.start();
        int exitCode = process.waitFor();
        
        if (exitCode == 0) {
            logger.info("✅ Резервна копія успішно відновлена: {}", 
                    backupFilepath);
            return true;
        }
        return false;
    } catch (Exception e) {
        logger.error("❌ Помилка при відновленні", e);
        return false;
    }
}
3.2.2 Блокування та розблокування пристроїв
DeviceFingerprintService — управління блокуванням пристроїв з логуванням дій (див. рисунок Б.2 для послідовності блокування).
Блокування пристрою адміністратором (рядки 105–118):

// БІЗНЕС-ЛОГІКА: Блокування пристрою
public DeviceFingerprint blockFingerprint(UUID fingerprintId, 
        UUID adminId, String reason) {
    Optional<DeviceFingerprint> fpOpt = 
            deviceFingerprintRepository.findById(fingerprintId);
    if (fpOpt.isEmpty()) {
        return null;
    }
    
    DeviceFingerprint fp = fpOpt.get();
    fp.setIsBlocked(true);
    fp.setBlockReason(reason);
    fp.setBlockedAt(LocalDateTime.now());
    fp.setBlockedByAdmin(new Admin() {{ setId(adminId); }});
    
    logAdminAction(adminId, "BLOCK_DEVICE", "DeviceFingerprint", 
            fingerprintId, "Blocked device: " + reason);
    
    return deviceFingerprintRepository.save(fp);
}
Розблокування пристрою (рядки 123–137):

// БІЗНЕС-ЛОГІКА: Розблокування пристрою
public DeviceFingerprint unblockFingerprint(UUID fingerprintId, 
        UUID adminId) {
    Optional<DeviceFingerprint> fpOpt = 
            deviceFingerprintRepository.findById(fingerprintId);
    if (fpOpt.isEmpty()) {
        return null;
    }
    
    DeviceFingerprint fp = fpOpt.get();
    fp.setIsBlocked(false);
    fp.setBlockReason(null);
    fp.setBlockedAt(null);
    fp.setBlockedByAdmin(null);
    
    logAdminAction(adminId, "UNBLOCK_DEVICE", "DeviceFingerprint", 
            fingerprintId, "Unblocked device");
    
    return deviceFingerprintRepository.save(fp);
}
3.2.3 Логування адміністративних дій
AdminService — управління логами дій адміністраторів та їх аналіз. Всі адміністративні дії логуються автоматично (див. рисунок Б.8 для цикла логування та аудиту).
Розрахунок статистики дій адміністраторів (рядки 108–145):

// МАТЕМАТИКА: Групування дій та розрахунок відсотків
public Map<String, Object> getAdminActivityStatistics(
        LocalDateTime from, LocalDateTime to) {
    List<AdminLog> logs = adminLogRepository.findAll().stream()
            .filter(log -> log.getCreatedAt().isAfter(from) && 
                    log.getCreatedAt().isBefore(to))
            .collect(Collectors.toList());
    
    Map<String, Object> stats = new LinkedHashMap<>();
    stats.put("period", from + " to " + to);
    stats.put("totalActions", logs.size());
    
    // МАТЕМАТИКА: Групування за типом дії
    Map<String, Long> actionCounts = logs.stream()
            .collect(Collectors.groupingBy(AdminLog::getAction, 
                    Collectors.counting()));
    
    // МАТЕМАТИКА: Розрахунок відсотків для кожної дії
    Map<String, Double> actionPercentages = new LinkedHashMap<>();
    actionCounts.forEach((action, count) -> {
        double percentage = logs.size() > 0
                ? (count * 100.0) / logs.size()
                : 0.0;
        actionPercentages.put(action, 
                Math.round(percentage * 100.0) / 100.0);
    });
    
    stats.put("actionCounts", actionCounts);
    stats.put("actionPercentages", actionPercentages);
    
    return stats;
}
3.2.4 Real-time трансляція результатів через WebSocket
WebSocketBroadcaster та PollWebSocketHandler — забезпечують трансляцію оновлених результатів голосувань усім підключеним клієнтам в режимі реального часу. Деталі взаємодії див. на рисунку Б.1 та Б.3 (метод broadcastPollResults() викликається автоматично після запису голосу та розрахунку статистики).
Трансляція результатів голосувань (WebSocketBroadcaster, рядки 18–27):

// БІЗНЕС-ЛОГІКА: Трансляція оновлених результатів
public void broadcastPollResults(UUID pollId, Object statistics) {
    Map<String, Object> data = new HashMap<>();
    data.put("type", "poll_results_update");
    data.put("topic", "polls/" + pollId + "/results");
    data.put("data", statistics);
    data.put("timestamp", System.currentTimeMillis());
    
    webSocketHandler.broadcast(
            "polls/" + pollId + "/results", data);
}
Загальна трансляція повідомлень (PollWebSocketHandler, рядки 78–106):

// БІЗНЕС-ЛОГІКА: Розсилання повідомлень усім підписникам
public void broadcast(String topic, Map<String, Object> data) {
    Set<WebSocketSession> subscribers = 
            pollSubscriptions.get(topic);
    
    if (subscribers == null || subscribers.isEmpty()) {
        logger.warn("⚠️ Немає підписників на тему: {}", topic);
        return;
    }
    
    try {
        String message = objectMapper.writeValueAsString(data);
        
        for (WebSocketSession session : 
                new HashSet<>(subscribers)) {
            if (session.isOpen()) {
                session.sendMessage(new TextMessage(message));
                logger.info("📤 Відправлено {}: {}", 
                        topic, session.getId());
            } else {
                subscribers.remove(session);
            }
        }
    } catch (Exception e) {
        logger.error("❌ Помилка при трансляції на {}: {}", 
                topic, e.getMessage());
    }
}
3.2.5 Управління варіантами голосувань з валідацією
PollOptionService — управління варіантами з автоматичним призначенням порядку.
Додавання варіанту з автоматичним orderNum (рядки 49–88):

// РЕФАКТОРИНГ: Валідація тексту варіанту
if (text == null || text.trim().isEmpty()) {
    logger.warn("Спроба додати варіант з пустим текстом");
    throw new IllegalArgumentException(
            "Текст варіанту не може бути пустим");
}

if (text.length() > MAX_OPTION_TEXT_LENGTH) {
    logger.warn("Текст має неправильну довжину: {}", text.length());
    throw new IllegalArgumentException(
            "Текст не повинен перевищувати " + 
            MAX_OPTION_TEXT_LENGTH + " символів");
}

// МАТЕМАТИКА: Визначення наступного orderNum
int nextOrderNum = getNextOrderNum(pollId);

PollOption option = new PollOption();
option.setPoll(poll);
option.setText(text.trim());
option.setOrderNum(nextOrderNum);

PollOption saved = pollOptionRepository.save(option);
logger.info("Варіант додано: '{}' з orderNum {}", text, nextOrderNum);
Розрахунок наступного порядкового номера (рядки 160–177):

// МАТЕМАТИКА: Визначення максимального orderNum
private int getNextOrderNum(UUID pollId) {
    Poll poll = pollRepository.findById(pollId).orElse(null);
    
    if (poll == null || poll.getOptions() == null || 
            poll.getOptions().isEmpty()) {
        return 0;
    }
    
    // МАТЕМАТИКА: max(orderNum) + 1
    int maxOrder = poll.getOptions().stream()
            .map(PollOption::getOrderNum)
            .filter(o -> o != null)
            .mapToInt(Integer::intValue)
            .max()
            .orElse(-1);
    
    return maxOrder + 1;
}
3.2.6 Експорт даних у CSV та PDF
ExportService — експорт результатів голосувань у різні формати.
Експорт у CSV формат (рядки 47–72):

// РЕФАКТОРИНГ: Правильне екранування CSV
public String exportPollToCsv(UUID pollId) {
    Poll poll = pollRepository.findById(pollId).orElse(null);
    if (poll == null) return null;
    
    Map<String, Object> stats = pollService
            .getPollStatistics(pollId);
    StringBuilder csv = new StringBuilder();
    
    // Заголовок
    csv.append("\"Голосування\",\"").append(
            escapeCsv(poll.getTitle())).append("\"\n");
    csv.append("\"Всього голосів\",").append(
            stats.get("totalVotes")).append("\n\n");
    
    // Таблиця результатів
    csv.append("\"Варіант\",\"Голосів\",\"Відсоток\"\n");
    
    @SuppressWarnings("unchecked")
    List<Map<String, Object>> options = 
            (List<Map<String, Object>>) stats.get("options");
    for (Map<String, Object> option : options) {
        csv.append("\"").append(
                escapeCsv((String) option.get("optionText")))
                .append("\",")
                .append(option.get("votes")).append(",")
                .append(option.get("percentage")).append("%\n");
    }
    
    return csv.toString();
}

// РЕФАКТОРИНГ: Утиліта для екранування CSV (заміна " на "")
private String escapeCsv(String value) {
    if (value == null) return "";
    return value.replace("\"", "\"\"");
}
     


     4 ВИСНОВКИ
     У ході виконання лабораторної роботи було успішно розроблено та реалізовано комплексну систему бізнес-логіки та функцій адміністрування серверної частини програми швидких голосувань.
     Бізнес-логіка включає:
• Розрахунок статистичних показників голосувань (Mean, StdDev, Variation Coefficient)
• Виявлення аномальної активності за Z-score методом
• Генерування унікальних device fingerprints за SHA-256 алгоритмом
• Перевірку на повторне голосування та блокування пристроїв
• Real-time трансляцію результатів через WebSocket
     Функції адміністрування охоплюють:
• Резервне копіювання та відновлення БД через pg_dump/psql
• Блокування та розблокування пристроїв з логуванням
• Статистичний аналіз дій адміністраторів (групування, відсотки)
• Валідацію варіантів голосування з автоматичним упорядкуванням
• Експорт результатів у CSV та PDF формати
     Реалізована архітектура забезпечує модульність, безпеку та масштабованість системи.
     

     ДОДАТОК А
     ВІДЕОЗАПИС
     https://www.youtube.com/watch?v=wsf0NsXKrpo
     Хронологічний опис відеозапису:
     00:00 — Представлення
     00:15 — Завдання лабораторної роботи
     00:40 — Архітектура бізнес-логіки та швидко по коду
     01:55 — Архітектура адміністрування та швидко по коду
     02:40 — Генерування QR-кодів для голосувань та швидко по коду
     03:28 — Логування адміністративних дій у всіх сервісах та швидко по коду
     04:32 —Демонстрація свагера та ендпоентів котрі будемо демонструвати
     05:15 — Помилковий початок тестування API
     06:45 — Правильний початок тестування API
     

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 — Діаграма послідовності: Реєстрація голосу (основний сценарій)

Рисунок Б.2 — Діаграма послідовності: Блокування пристрою адміністратором

Рисунок Б.3 — Діаграма послідовності: Розрахунок статистики голосувань

Рисунок Б.4 — Діаграма послідовності: Виявлення аномалій активності пристроїв

Рисунок Б.5 — Діаграма діяльності: Повний цикл життя опитування

Рисунок Б.6 — Діаграма діяльності: Валідація користувача та пристрою

Рисунок Б.7 — Діаграма діяльності: Адміністрування та аудит системи


ДОДАТОК В
Специфікація API
     Порівнюючи Lab2 та впроваджений код:
     Для бізнес-логіки (PollService):
     GET  /api/polls/trending                    # Тренди (найактивніші)
     GET  /api/polls/{id}/statistics             # Статистика по опитуванню
     GET  /api/polls/{id}/metrics                # Математичні метрики
          (mean, stdDeviation, coefficientOfVariation, min, max)
     Для адміністрування пристроїв (DeviceFingerprintService):
     GET  /api/device-fingerprints/{id}/statistics    # Статистика пристрою
     PUT  /api/device-fingerprints/{id}/block         # Заблокувати
     PUT  /api/device-fingerprints/{id}/unblock       # Розблокувати
     GET  /api/device-fingerprints/blocked            # Список заблокованих
     Для експорту (ExportService):
     GET  /api/polls/{id}/export/csv             # Експорт результатів у CSV
     GET  /api/polls/export/csv                  # Експорт всіх опитувань
     GET  /api/polls/{id}/votes/export/csv       # Експорт голосів опитування
     GET  /api/polls/{id}/export/pdf             # Експорт у PDF
     Для QR-кодів (QrCodeService):
     GET  /api/polls/{id}/qr                     # Отримати URL QR-кода
     WebSocket для real-time (WebSocketService):
     /topic/polls/{id}/results                   # Результати в режимі реального часу
     /topic/polls/new                            # Нові опитування
     /topic/polls/{id}/status                    # Статус опитування
     /topic/polls/{id}/users                     # Активні користувачі
     /app/polls/{id}/subscribe                   # Підписка на результати
     Для адміністраторів (AdminService):
     PUT  /api/admins/{id}/deactivate            # Деактивувати адміна
     POST /api/admin-logs/statistics             # Статистика логів за період



